name: Build luci-app-aurora-config

on:
  workflow_dispatch:
    inputs:
      sdk_url:
        description: 'OpenWrt SDK 下載地址 (.tar.zst)'
        required: true
        default: 'https://downloads.openwrt.org/releases/24.10.5/targets/rockchip/armv8/openwrt-sdk-24.10.5-rockchip-armv8_gcc-13.3.0_musl.Linux-x86_64.tar.zst'

env:
  PLUGIN_REPO: "https://github.com/eamonxg/luci-app-aurora-config.git"
  PACKAGE_NAME: "luci-app-aurora-config"

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
      - name: 初始化環境
        uses: actions/checkout@v4

      - name: 安裝編譯依賴與 OpenCC
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential clang flex bison g++ gawk \
            gcc-multilib g++-multilib gettext git libncurses-dev libssl-dev \
            python3-distutils rsync unzip zlib1g-dev file wget zstd \
            ccache ecj fastjar libelf-dev xsltproc python3-pyelftools \
            opencc

      - name: 下載並解壓 SDK
        run: |
          SDK_URL="${{ inputs.sdk_url }}"
          SDK_FILE=$(basename "$SDK_URL")
          
          echo "正在下載 SDK: $SDK_FILE"
          wget -qO "$SDK_FILE" "$SDK_URL"
          
          echo "正在解壓 SDK..."
          mkdir sdk
          tar -I zstd -xf "$SDK_FILE" -C sdk --strip-components=1
          rm -f "$SDK_FILE"

      - name: 下載插件原始碼
        working-directory: ./sdk/package
        run: |
          git clone "$PLUGIN_REPO"

      - name: 檢測並自動生成繁體中文 (OpenCC)
        working-directory: ./sdk/package
        run: |
          # 1. 進入插件目錄
          PKG_DIR=$(find . -maxdepth 1 -type d -name "*aurora-config*" | head -n 1)
          if [ -z "$PKG_DIR" ]; then echo "錯誤：找不到插件目錄"; exit 1; fi
          cd "$PKG_DIR"
          echo "進入目錄: $(pwd)"

          PO_DIR="po"
          
          if [ ! -d "$PO_DIR" ]; then
            echo "警告：未找到 po 目錄，跳過翻譯處理。"
            exit 0
          fi

          # --- 步驟 1: 規範化來源目錄名稱 (zh-cn -> zh_Hans) ---
          if [ -d "$PO_DIR/zh-cn" ] && [ ! -d "$PO_DIR/zh_Hans" ]; then
            echo "檢測到非標準命名：將 po/zh-cn 重命名為 po/zh_Hans"
            mv "$PO_DIR/zh-cn" "$PO_DIR/zh_Hans"
          fi

          # --- 步驟 2: 檢測繁體中文是否存在 ---
          if [ -d "$PO_DIR/zh_Hant" ] || [ -d "$PO_DIR/zh-tw" ]; then
            echo "檢測到已存在繁體中文目錄，跳過轉換。"
            exit 0
          fi

          # --- 步驟 3: 若不存在繁體，則由簡體轉換 (zh_Hans -> zh_Hant) ---
          if [ -d "$PO_DIR/zh_Hans" ]; then
            echo "未檢測到繁體中文，準備從 zh_Hans 轉換..."
            mkdir -p "$PO_DIR/zh_Hant"

            for file in "$PO_DIR/zh_Hans"/*.po; do
              [ -e "$file" ] || continue
              filename=$(basename "$file")
              echo "正在轉換: $filename"

              # A. 使用 OpenCC 轉換 (s2tw: 簡體 -> 台灣正體)
              opencc -c s2tw -i "$file" -o "$PO_DIR/zh_Hant/$filename"

              # B. 修正 .po 標頭與語言代碼
              sed -i 's/zh_Hans/zh_Hant/g' "$PO_DIR/zh_Hant/$filename"
              sed -i 's/zh_CN/zh_Hant/g'   "$PO_DIR/zh_Hant/$filename"
              sed -i 's/zh-cn/zh_Hant/g'   "$PO_DIR/zh_Hant/$filename"
              
              # C. 術語修正
              sed -i 's/配置文件/設定檔/g' "$PO_DIR/zh_Hant/$filename"
              sed -i 's/配置/設定/g'      "$PO_DIR/zh_Hant/$filename"
              sed -i 's/保存/儲存/g'      "$PO_DIR/zh_Hant/$filename"
              sed -i 's/应用/套用/g'      "$PO_DIR/zh_Hant/$filename"
              sed -i 's/启用/啟用/g'      "$PO_DIR/zh_Hant/$filename"
            done
            echo "轉換完成！"
          else
            echo "警告：找不到 zh_Hans 來源，無法轉換。"
          fi

      - name: 更新並安裝 Feeds
        working-directory: ./sdk
        run: |
          ./scripts/feeds update -a
          ./scripts/feeds install -a

      - name: 配置並編譯
        working-directory: ./sdk
        run: |
          make defconfig
          echo "CONFIG_PACKAGE_$PACKAGE_NAME=m" >> .config
          make defconfig
          grep "CONFIG_PACKAGE_$PACKAGE_NAME=m" .config || { echo "錯誤：配置未生效"; exit 1; }
          
          echo "開始編譯 $PACKAGE_NAME ..."
          make package/$PACKAGE_NAME/compile V=s -j$(nproc)

      - name: 整理並重命名安裝包
        run: |
          mkdir -p output
          
          echo "Package Name defined as: $PACKAGE_NAME"
          
          # 遍歷 sdk/bin 下所有符合條件的 ipk 與 apk 文件
          find sdk/bin -type f -name "*aurora-config*" \( -name "*.ipk" -o -name "*.apk" \) | while read -r filepath; do
            filename=$(basename "$filepath")
            ext="${filename##*.}"
            
            # --- 判斷邏輯開始 ---
            # 檢查檔名開頭是否完全匹配 PACKAGE_NAME (加上分隔符 _ 或 - 以確保精確匹配)
            if [[ "$filename" == "$PACKAGE_NAME"_* ]] || [[ "$filename" == "$PACKAGE_NAME"-* ]]; then
              
              # 情況 A：本體插件 -> 直接複製，不改名
              echo "保留本體原名: $filename"
              cp "$filepath" "output/$filename"
              
            else
              
              # 情況 B：附屬包 (如 i18n, l10n) -> 修改版本號為 0
              if [[ "$ext" == "ipk" ]]; then
                # IPK: name_version_arch.ipk -> name_0_arch.ipk
                new_filename=$(echo "$filename" | sed -E 's/^(.*)_([^_]+)_([^_]+\.ipk)$/\1_0_\3/')
              elif [[ "$ext" == "apk" ]]; then
                # APK: name-version.apk -> name-0.apk
                new_filename=$(echo "$filename" | sed -E 's/^(.*)-([^-]+)\.apk$/\1-0.apk/')
              fi
              
              echo "重命名並複製: $filename -> $new_filename"
              cp "$filepath" "output/$new_filename"
            fi
            # --- 判斷邏輯結束 ---
            
          done
          
          echo "--- 輸出目錄最終內容 ---"
          ls -lh output/
          
          if [ -z "$(ls -A output)" ]; then
              echo "錯誤：未找到編譯出的文件！"
              exit 1
          fi

      - name: 設定成品標識
        id: set_name
        run: |
          SDK_URL="${{ inputs.sdk_url }}"
          
          if [[ "$SDK_URL" == *"snapshots"* ]]; then
            OP_VERSION="SNAPSHOT"
          elif [[ "$SDK_URL" == *"releases"* ]]; then
            OP_VERSION=$(echo "$SDK_URL" | awk -F'/releases/' '{print $2}' | awk -F'/' '{print $1}')
          else
            OP_VERSION="Custom"
          fi
          
          echo "偵測到的 SDK 版本: $OP_VERSION"
          echo "ARTIFACT_SUFFIX=$OP_VERSION" >> $GITHUB_ENV

      - name: 上傳成品
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PACKAGE_NAME }}-${{ env.ARTIFACT_SUFFIX }}
          path: output/*

name: Build Any LuCI Plugin (Auto-Detect)

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: '插件 Git 倉庫地址 (必填)'
        required: true
        default: 'https://github.com/gSpotx2f/luci-app-temp-status.git'
      sdk_url:
        description: 'OpenWrt SDK 下載地址'
        required: true
        default: 'https://downloads.openwrt.org/releases/24.10.5/targets/rockchip/armv8/openwrt-sdk-24.10.5-rockchip-armv8_gcc-13.3.0_musl.Linux-x86_64.tar.zst'

env:
  TZ: Asia/Taipei

jobs:
  build:
    runs-on: ubuntu-22.04

    steps:
      - name: 初始化環境
        uses: actions/checkout@v4

      - name: 安裝編譯依賴與 OpenCC
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential clang flex bison g++ gawk \
            gcc-multilib g++-multilib gettext git libncurses-dev libssl-dev \
            python3-distutils rsync unzip zlib1g-dev file wget zstd \
            ccache ecj fastjar libelf-dev xsltproc python3-pyelftools \
            opencc

      - name: 下載並解壓 SDK
        run: |
          SDK_URL="${{ inputs.sdk_url }}"
          SDK_FILE=$(basename "$SDK_URL")
          
          echo "正在下載 SDK: $SDK_FILE"
          wget -qO "$SDK_FILE" "$SDK_URL"
          
          echo "正在解壓 SDK..."
          mkdir sdk
          tar -I zstd -xf "$SDK_FILE" -C sdk --strip-components=1
          rm -f "$SDK_FILE"

      - name: 下載插件並自動提取名稱
        working-directory: ./sdk/package
        run: |
          REPO_URL="${{ inputs.repo_url }}"
          git clone "$REPO_URL"
          
          # 從 URL 提取倉庫名稱作為預設 PACKAGE_NAME
          PKG_NAME=$(basename "$REPO_URL" .git)
          echo "偵測到的插件名稱: $PKG_NAME"
          echo "PACKAGE_NAME=$PKG_NAME" >> $GITHUB_ENV

      - name: 標準化語言包並轉換繁體 (OpenCC)
        working-directory: ./sdk/package
        run: |
          # ------------------------------------------------------------------
          # 1. 智能目錄搜尋 (處理二級目錄問題)
          # ------------------------------------------------------------------
          echo "正在搜尋插件真實路徑 (Target: $PACKAGE_NAME)..."
          
          # 先找出剛 Clone 下來的最外層目錄
          CLONE_DIR=$(find . -maxdepth 1 -type d -name "*$PACKAGE_NAME*" | head -n 1)
          if [ -z "$CLONE_DIR" ]; then echo "錯誤：Git Clone 失敗或找不到目錄"; exit 1; fi
          
          cd "$CLONE_DIR"
          echo "進入 Clone 根目錄: $(pwd)"
          
          # 判斷 Makefile 位置
          if [ -f "Makefile" ]; then
             PKG_REAL_DIR="."
          else
             # 遞迴搜尋含有 Makefile 的子目錄
             PKG_REAL_DIR=$(find . -type d -name "*$PACKAGE_NAME*" -exec test -f "{}/Makefile" \; -print -quit)
             # 若依名稱找不到，嘗試搜尋任意含有 Makefile 的目錄 (排除 src)
             if [ -z "$PKG_REAL_DIR" ]; then
                PKG_REAL_DIR=$(find . -maxdepth 2 -type d -not -name "src" -exec test -f "{}/Makefile" \; -print -quit)
             fi
          fi
          
          if [ -z "$PKG_REAL_DIR" ]; then echo "錯誤：無法定位包含 Makefile 的插件目錄！"; exit 1; fi
          
          cd "$PKG_REAL_DIR"
          echo ">>> 最終鎖定插件目錄: $(pwd)"

          # ------------------------------------------------------------------
          # 2. 語言包處理邏輯 (標準化 -> 檢測 -> 轉換)
          # ------------------------------------------------------------------
          PO_DIR="po"
          TARGET_HANS="$PO_DIR/zh_Hans"
          TARGET_HANT="$PO_DIR/zh_Hant"

          # [步驟 A] 標準化目錄名稱 (Normalize)
          # 目的：將 zh-cn, zh_CN -> zh_Hans；將 zh-tw, zh_TW -> zh_Hant
          
          # 處理簡體
          for legacy in "$PO_DIR/zh-cn" "$PO_DIR/zh_CN" "$PO_DIR/zh_cn"; do
            if [ -d "$legacy" ]; then
              if [ -d "$TARGET_HANS" ]; then
                echo "移除重複的舊版簡體目錄: $legacy"
                rm -rf "$legacy"
              else
                echo "標準化簡體命名: $legacy -> $TARGET_HANS"
                mv "$legacy" "$TARGET_HANS"
                # 修正 po 檔內的 Header
                find "$TARGET_HANS" -name "*.po" -exec sed -i 's/"Language: zh_CN/"Language: zh_Hans/g' {} +
                find "$TARGET_HANS" -name "*.po" -exec sed -i 's/"Language: zh-cn/"Language: zh_Hans/g' {} +
              fi
            fi
          done

          # 處理繁體
          for legacy in "$PO_DIR/zh-tw" "$PO_DIR/zh_TW" "$PO_DIR/zh_tw"; do
            if [ -d "$legacy" ]; then
              if [ -d "$TARGET_HANT" ]; then
                echo "移除重複的舊版繁體目錄: $legacy"
                rm -rf "$legacy"
              else
                echo "標準化繁體命名: $legacy -> $TARGET_HANT"
                mv "$legacy" "$TARGET_HANT"
                # 修正 po 檔內的 Header
                find "$TARGET_HANT" -name "*.po" -exec sed -i 's/"Language: zh_TW/"Language: zh_Hant/g' {} +
                find "$TARGET_HANT" -name "*.po" -exec sed -i 's/"Language: zh-tw/"Language: zh_Hant/g' {} +
              fi
            fi
          done

          # [步驟 B] 檢測繁體是否存在，若不存在則由簡體轉換
          if [ -d "$TARGET_HANT" ]; then
            echo ">>> 檢測到 zh_Hant 已存在 (包含由 zh-tw 標準化而來的)，跳過轉換。"
          else
            if [ -d "$TARGET_HANS" ]; then
              echo ">>> 未檢測到 zh_Hant，正在從 zh_Hans 轉換..."
              mkdir -p "$TARGET_HANT"
              
              for file in "$TARGET_HANS"/*.po; do
                [ -e "$file" ] || continue
                filename=$(basename "$file")
                
                # OpenCC 轉換 (簡 -> 繁)
                opencc -c s2tw -i "$file" -o "$TARGET_HANT/$filename"
                
                # 修正 Header (Hans -> Hant)
                sed -i 's/"Language: zh_Hans/"Language: zh_Hant/g' "$TARGET_HANT/$filename"
                
                # 詞彙潤飾 (可選)
                sed -i "s/配置文件/設定檔/g" "$TARGET_HANT/$filename"
                sed -i "s/配置/設定/g" "$TARGET_HANT/$filename"
                sed -i "s/保存/儲存/g" "$TARGET_HANT/$filename"
                sed -i "s/應用/套用/g" "$TARGET_HANT/$filename"
              done
              echo ">>> 轉換完成！"
            else
              echo ">>> 提示：找不到 zh_Hans 來源，無法進行轉換。"
            fi
          fi

      - name: 更新並安裝 Feeds
        working-directory: ./sdk
        run: |
          ./scripts/feeds update -a
          ./scripts/feeds install -a

      - name: 配置並編譯
        working-directory: ./sdk
        run: |
          make defconfig
          echo "CONFIG_PACKAGE_$PACKAGE_NAME=m" >> .config
          make defconfig
          
          echo "開始編譯 $PACKAGE_NAME ..."
          make package/$PACKAGE_NAME/compile V=s -j$(nproc)

      - name: 整理並重新命名安裝包
        run: |
          mkdir -p output
          find sdk/bin -type f -name "*$PACKAGE_NAME*" \( -name "*.ipk" -o -name "*.apk" \) -exec cp
